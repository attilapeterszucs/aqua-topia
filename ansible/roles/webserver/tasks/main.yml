---
# Webserver Configuration Tasks
# Deploys rootless containers, configures TLS, firewall, and SELinux

# ============================================
# Package Installation
# ============================================
- name: Check if system is RHEL/CentOS
  ansible.builtin.stat:
    path: /etc/redhat-release
  register: redhat_release
  tags:
    - packages

- name: Install EPEL repository (RHEL/CentOS)
  ansible.builtin.dnf:
    name: epel-release
    state: present
  ignore_errors: true
  register: epel_pkg_install
  tags:
    - packages
    - repos

- name: Install EPEL repository via RPM (if package method failed)
  ansible.builtin.dnf:
    name: https://dl.fedoraproject.org/pub/epel/epel-release-latest-9.noarch.rpm
    state: present
    disable_gpg_check: true
  when: epel_pkg_install.failed
  ignore_errors: true
  register: epel_rpm_install
  tags:
    - packages
    - repos

- name: Install Podman and system dependencies
  ansible.builtin.dnf:
    name:
      - podman
      - skopeo
      - firewalld
      - policycoreutils-python-utils  # For SELinux management
      - python3-pip  # For certbot installation
    state: present
  tags:
    - packages

- name: Install certbot from repositories
  ansible.builtin.dnf:
    name:
      - certbot
    state: present
  ignore_errors: true
  register: certbot_install
  tags:
    - packages
    - certbot

- name: Install certbot via pip if package installation failed
  ansible.builtin.pip:
    name:
      - certbot
    state: present
  when: certbot_install.failed or certbot_install.rc != 0
  ignore_errors: true
  tags:
    - packages
    - certbot

# ============================================
# User Configuration
# ============================================
- name: Ensure application user exists
  ansible.builtin.user:
    name: "{{ app_user }}"
    comment: "Aqua Topia Application User"
    shell: /bin/bash
    create_home: true
  tags:
    - users

- name: Enable lingering for application user (required for rootless systemd)
  ansible.builtin.command: loginctl enable-linger {{ app_user }}
  args:
    creates: /var/lib/systemd/linger/{{ app_user }}
  tags:
    - systemd

- name: Create systemd user directory
  ansible.builtin.file:
    path: "{{ systemd_user_dir }}"
    state: directory
    owner: "{{ app_user }}"
    group: "{{ app_group }}"
    mode: '0755'
  tags:
    - systemd

# ============================================
# Container Registry and Image
# ============================================
- name: Check if logged in to container registry
  ansible.builtin.command: podman login --get-login {{ container_registry }}
  register: registry_status
  changed_when: false
  failed_when: false
  become_user: "{{ app_user }}"
  tags:
    - containers

- name: Pull container image from registry
  ansible.builtin.command: podman pull {{ container_image }}:{{ container_tag }}
  become_user: "{{ app_user }}"
  when: registry_status.rc == 0
  register: podman_pull_result
  changed_when: "'Downloaded newer image' in podman_pull_result.stdout or 'Pulling' in podman_pull_result.stderr"
  failed_when: podman_pull_result.rc != 0
  tags:
    - containers

# ============================================
# Systemd Service Deployment
# ============================================
- name: Deploy systemd service file for rootless container
  ansible.builtin.copy:
    src: "../../../systemd/aqua-topia-app.service"
    dest: "{{ systemd_user_dir }}/{{ systemd_service_name }}.service"
    owner: "{{ app_user }}"
    group: "{{ app_group }}"
    mode: '0644'
  notify: Reload systemd user daemon
  tags:
    - systemd
    - deployment

- name: Reload systemd user daemon
  ansible.builtin.systemd:
    daemon_reload: true
    scope: user
  become_user: "{{ app_user }}"
  environment:
    XDG_RUNTIME_DIR: "/run/user/{{ ansible_facts['user_uid'] }}"
  tags:
    - systemd

- name: Enable and start application service
  ansible.builtin.systemd:
    name: "{{ systemd_service_name }}"
    enabled: true
    state: started
    scope: user
  become_user: "{{ app_user }}"
  environment:
    XDG_RUNTIME_DIR: "/run/user/{{ ansible_facts['user_uid'] }}"
  notify: Restart aqua-topia-app
  tags:
    - systemd
    - deployment

# ============================================
# Firewalld Configuration
# ============================================
- name: Ensure firewalld is installed and running
  ansible.builtin.systemd:
    name: firewalld
    state: started
    enabled: true
  tags:
    - firewall

- name: Configure firewalld ports for Aqua Topia
  ansible.builtin.command: firewall-cmd --permanent --add-port={{ item }}
  loop: "{{ firewall_ports }}"
  register: firewall_port_result
  changed_when: firewall_port_result.rc == 0
  failed_when: false
  notify: Reload firewalld
  tags:
    - firewall

- name: Reload firewalld to apply port changes
  ansible.builtin.command: firewall-cmd --reload
  when: firewall_port_result.changed
  tags:
    - firewall

- name: Add rich rule for subnet access
  ansible.builtin.command: firewall-cmd --permanent --add-rich-rule="rule family='ipv4' source address='{{ subnet }}' accept"
  register: rich_rule_result
  changed_when: rich_rule_result.rc == 0
  failed_when: false
  notify: Reload firewalld
  tags:
    - firewall

- name: Set default zone to public
  ansible.builtin.command: firewall-cmd --set-default-zone=public
  changed_when: false
  tags:
    - firewall

# ============================================
# SELinux Configuration
# ============================================
- name: Check current SELinux status
  ansible.builtin.command: getenforce
  register: current_selinux
  changed_when: false
  tags:
    - selinux

- name: Set SELinux to enforcing mode
  ansible.builtin.command: setenforce 1
  when:
    - selinux_state == "enforcing"
    - current_selinux.stdout != "Enforcing"
  register: selinux_enforce_result
  changed_when: selinux_enforce_result.rc == 0
  failed_when: false
  tags:
    - selinux

- name: Set SELinux to permissive mode (if configured)
  ansible.builtin.command: setenforce 0
  when:
    - selinux_state == "permissive"
    - current_selinux.stdout != "Permissive"
  register: selinux_permissive_result
  changed_when: selinux_permissive_result.rc == 0
  failed_when: false
  tags:
    - selinux

- name: Set SELinux to disabled in config (if configured)
  ansible.builtin.lineinfile:
    path: /etc/selinux/config
    regexp: '^SELINUX='
    line: 'SELINUX=disabled'
  when: selinux_state == "disabled"
  tags:
    - selinux

- name: Warn about SELinux disabled requiring reboot
  ansible.builtin.debug:
    msg: "WARNING: SELinux disabled state requires a system reboot to take effect"
  when: selinux_state == "disabled"
  tags:
    - selinux

- name: Configure SELinux context for container storage
  ansible.builtin.command: >
    semanage fcontext -a -t container_file_t "{{ container_storage_dir }}(/.*)?"
  when: selinux_state == "enforcing"
  failed_when: false
  tags:
    - selinux

- name: Apply SELinux context to container storage
  ansible.builtin.command: restorecon -Rv {{ container_storage_dir }}
  when: selinux_state == "enforcing"
  changed_when: false
  failed_when: false
  tags:
    - selinux

# ============================================
# TLS Certificate Setup (Certbot)
# ============================================
- name: Create proxy configuration directory
  ansible.builtin.file:
    path: "{{ proxy_config_dir }}"
    state: directory
    owner: root
    group: root
    mode: '0755'
  tags:
    - tls
    - proxy

- name: Deploy Mozilla TLS configuration
  ansible.builtin.copy:
    src: "../../../certbot/mozilla-tls-config.conf"
    dest: "{{ proxy_config_dir }}/mozilla-tls-config.conf"
    owner: root
    group: root
    mode: '0644'
  tags:
    - tls
    - proxy

- name: Request Let's Encrypt certificate via HTTP-01 challenge
  ansible.builtin.command: >
    certbot certonly --standalone --non-interactive --agree-tos
    --email {{ certbot_email }}
    --domains {{ domain }}
    --http-01-port {{ http_port }}
  args:
    creates: "{{ cert_path }}/fullchain.pem"
  tags:
    - tls
    - certbot

- name: Set up Certbot auto-renewal systemd timer
  ansible.builtin.systemd:
    name: certbot-renew.timer
    enabled: true
    state: started
  tags:
    - tls
    - certbot

- name: Verify certificate file permissions
  ansible.builtin.file:
    path: "{{ cert_path }}"
    state: directory
    mode: '0755'
  when: cert_path is defined
  tags:
    - tls

# ============================================
# Health Check
# ============================================
- name: Wait for application to be ready
  ansible.builtin.wait_for:
    port: "{{ app_port }}"
    host: localhost
    timeout: 60
  tags:
    - deployment
    - healthcheck
