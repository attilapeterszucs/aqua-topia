---
# Webserver Configuration Tasks
# Deploys rootless containers, configures TLS, firewall, and SELinux

# ============================================
# Package Installation
# ============================================
- name: Install Podman and system dependencies
  ansible.builtin.dnf:
    name:
      - podman
      - skopeo
      - firewalld
      - certbot
      - python3-certbot
      - policycoreutils-python-utils  # For SELinux management
    state: present
  tags:
    - packages

# ============================================
# User Configuration
# ============================================
- name: Ensure application user exists
  ansible.builtin.user:
    name: "{{ app_user }}"
    comment: "Aqua Topia Application User"
    shell: /bin/bash
    create_home: true
  tags:
    - users

- name: Enable lingering for application user (required for rootless systemd)
  ansible.builtin.command: loginctl enable-linger {{ app_user }}
  args:
    creates: /var/lib/systemd/linger/{{ app_user }}
  tags:
    - systemd

- name: Create systemd user directory
  ansible.builtin.file:
    path: "{{ systemd_user_dir }}"
    state: directory
    owner: "{{ app_user }}"
    group: "{{ app_group }}"
    mode: '0755'
  tags:
    - systemd

# ============================================
# Container Registry and Image
# ============================================
- name: Check if logged in to container registry
  ansible.builtin.command: podman login --get-login {{ container_registry }}
  register: registry_status
  changed_when: false
  failed_when: false
  become_user: "{{ app_user }}"
  tags:
    - containers

- name: Pull container image from registry
  containers.podman.podman_image:
    name: "{{ container_image }}:{{ container_tag }}"
    state: present
  become_user: "{{ app_user }}"
  when: registry_status.rc == 0
  tags:
    - containers

# ============================================
# Systemd Service Deployment
# ============================================
- name: Deploy systemd service file for rootless container
  ansible.builtin.copy:
    src: "../../../systemd/aqua-topia-app.service"
    dest: "{{ systemd_user_dir }}/{{ systemd_service_name }}.service"
    owner: "{{ app_user }}"
    group: "{{ app_group }}"
    mode: '0644'
  notify: Reload systemd user daemon
  tags:
    - systemd
    - deployment

- name: Reload systemd user daemon
  ansible.builtin.systemd:
    daemon_reload: true
    scope: user
  become_user: "{{ app_user }}"
  environment:
    XDG_RUNTIME_DIR: "/run/user/{{ ansible_facts['user_uid'] }}"
  tags:
    - systemd

- name: Enable and start application service
  ansible.builtin.systemd:
    name: "{{ systemd_service_name }}"
    enabled: true
    state: started
    scope: user
  become_user: "{{ app_user }}"
  environment:
    XDG_RUNTIME_DIR: "/run/user/{{ ansible_facts['user_uid'] }}"
  notify: Restart aqua-topia-app
  tags:
    - systemd
    - deployment

# ============================================
# Firewalld Configuration
# ============================================
- name: Ensure firewalld is installed and running
  ansible.builtin.systemd:
    name: firewalld
    state: started
    enabled: true
  tags:
    - firewall

- name: Configure firewalld ports for Aqua Topia
  ansible.posix.firewalld:
    port: "{{ item }}"
    permanent: true
    state: enabled
    immediate: true
  loop: "{{ firewall_ports }}"
  notify: Reload firewalld
  tags:
    - firewall

- name: Add rich rule for subnet access
  ansible.posix.firewalld:
    rich_rule: "rule family='ipv4' source address='{{ subnet }}' accept"
    permanent: true
    state: enabled
    immediate: true
  notify: Reload firewalld
  tags:
    - firewall

- name: Set default zone to public
  ansible.builtin.command: firewall-cmd --set-default-zone=public
  changed_when: false
  tags:
    - firewall

# ============================================
# SELinux Configuration
# ============================================
- name: Check current SELinux status
  ansible.builtin.command: getenforce
  register: current_selinux
  changed_when: false
  tags:
    - selinux

- name: Set SELinux to enforcing mode
  ansible.posix.selinux:
    policy: "{{ selinux_policy }}"
    state: "{{ selinux_state }}"
  when: selinux_state == "enforcing"
  tags:
    - selinux

- name: Set SELinux to permissive mode (if configured)
  ansible.posix.selinux:
    policy: "{{ selinux_policy }}"
    state: "{{ selinux_state }}"
  when: selinux_state == "permissive"
  tags:
    - selinux

- name: Set SELinux to disabled (if configured)
  ansible.posix.selinux:
    state: disabled
  when: selinux_state == "disabled"
  tags:
    - selinux

- name: Configure SELinux context for container storage
  ansible.builtin.command: >
    semanage fcontext -a -t container_file_t "{{ container_storage_dir }}(/.*)?"
  when: selinux_state == "enforcing"
  failed_when: false
  tags:
    - selinux

- name: Apply SELinux context to container storage
  ansible.builtin.command: restorecon -Rv {{ container_storage_dir }}
  when: selinux_state == "enforcing"
  changed_when: false
  failed_when: false
  tags:
    - selinux

# ============================================
# TLS Certificate Setup (Certbot)
# ============================================
- name: Create proxy configuration directory
  ansible.builtin.file:
    path: "{{ proxy_config_dir }}"
    state: directory
    owner: root
    group: root
    mode: '0755'
  tags:
    - tls
    - proxy

- name: Deploy Mozilla TLS configuration
  ansible.builtin.copy:
    src: "../../../certbot/mozilla-tls-config.conf"
    dest: "{{ proxy_config_dir }}/mozilla-tls-config.conf"
    owner: root
    group: root
    mode: '0644'
  tags:
    - tls
    - proxy

- name: Request Let's Encrypt certificate via HTTP-01 challenge
  ansible.builtin.command: >
    certbot certonly --standalone --non-interactive --agree-tos
    --email {{ certbot_email }}
    --domains {{ domain }}
    --http-01-port {{ http_port }}
  args:
    creates: "{{ cert_path }}/fullchain.pem"
  tags:
    - tls
    - certbot

- name: Set up Certbot auto-renewal systemd timer
  ansible.builtin.systemd:
    name: certbot-renew.timer
    enabled: true
    state: started
  tags:
    - tls
    - certbot

- name: Verify certificate file permissions
  ansible.builtin.file:
    path: "{{ cert_path }}"
    state: directory
    mode: '0755'
  when: cert_path is defined
  tags:
    - tls

# ============================================
# Health Check
# ============================================
- name: Wait for application to be ready
  ansible.builtin.wait_for:
    port: "{{ app_port }}"
    host: localhost
    timeout: 60
  tags:
    - deployment
    - healthcheck
